classdef marketObject_new < handle
    % Market objeect with new sleek table design
    
    properties (SetAccess=private)
        % Table with users and public key for signatures
        userTable = table([], {}, 'VariableNames', {'traderId',...
            'verifyKey'});
        % Order book for all trades, including including order book,
        % matched, and linked trades (offsets, partials, etc)
        orderBook = table([], [], [], [], [], [], [], [], {}, {},...
            'VariableNames',...
            {'tradeRootId', 'tradeBranchId', 'isMatched', 'price',...
            'quantity', 'marketRootId', 'marketBranchId', 'traderId',...
            'signatureMsg', 'signature'});
        % Market table with minimum and maximum of each market.
        marketTable = table([], [], [], [], [], {}, {}, 'VariableNames',...
            {'marketRootId', 'marketBranchId', 'marketMin', 'marketMax',...
            'traderId', 'signatureMsg', 'signature'});
        
    end % Properties
    
    
    methods (Access = public)
        
        function this = createUser(this, inputStruct)
            % Create a new row in userTable 
            % e.g. mo.createUser('verifyKey', 'a')
            this.struct2var(inputStruct);
            
            % Number of users in table
            numUsers = height(this.userTable);
            % Add new user if not already in table
            if ~ismember(verifyKey, this.userTable.verifyKey)
                traderId = numUsers+1;
                newUser = table(traderId, {verifyKey}, 'VariableNames',...
                    {'traderId', 'verifyKey'});
                this.userTable = vertcat(this.userTable, newUser);
                display(['traderId:' num2str(traderId)])
            else
                display('Verify key already exists');
            end
        end % createUser
        
        function this = createMarket(this, inputStruct)
            % Create a new row in marketTable
            % e.g. mo.createMarket(struct('marketRootId', 1, 'marketBranchId', 1,...
            %                    'marketMin', 0, 'marketMax', 1,...
            %                    'traderId', 1, 'signatureMsg','sig',...
            %                    'signature', 1);
            %                   
            % Handle inputs
            this.struct2var(inputStruct);
            
            % New market
            newMarket = table(marketRootId, marketBranchId, marketMin,...
                marketMax, traderId, {signatureMsg}, {signature}, 'VariableNames',...
                {'marketRootId', 'marketBranchId', 'marketMin', 'marketMax',...
                'traderId', 'signatureMsg', 'signature'});
            
            % Checks (correct market number, signature relative to correct parent market)
            checks = 1;
            
            % Add market if checks pass
            if checks
                this.marketTable = vertcat(this.marketTable, newMarket);
            end
            
        end % createMarket
        
        function this = createTrade(this, inputStruct)
            % - Create new trade for trade table
            % - Check that sufficient collateral exists for trade
            % (checkCollateral)
            % - Add trade to this.tradeTable
            
            % e.g. mo.createTrade(struct('traderId', 1, 'tradeRootId', 1, 'tradeBranchId', 1,...
            %                    'isMatched', 0, 'price', 0.5,...
            %                    'quantity', 10, 'marketRootId', 1,...
            %                    'marketBranchId', 1,'signatureMsg',...
            %                    'sigMsg', 'signature', 'sig'));  
            %                   
            % Handle inputs
            this.struct2var(inputStruct);
            % Create a new trade in orderBook.
            
            % Checks (markets exist, signature relative to parents)
            checks = 1
            
            if checks
                newTrade = table(tradeRootId, tradeBranchId, isMatched,...
                    price, quantity, marketRootId, marketBranchId, traderId,...
                    {signatureMsg}, {signature},...
                    'VariableNames',...
                    {'tradeRootId', 'tradeBranchId' 'isMatched', 'price',...
                    'quantity', 'marketRootId', 'marketBranchId', 'traderId',...
                    'signatureMsg', 'signature'});
                % TODO: eventualy this check will be unnecessary because it
                % will get checked properly in matchTrades
                colChk = this.checkCollateral(newTrade)
                if colChk
                    % Add trades and match
                    this.orderBook = vertcat(this.orderBook, newTrade);
                    this.matchTrades();
                else
                    display('Collateral check failed');
                end % colChk
            end % checks
            
        end % createTrade
        
    end % Public methods
    
    methods (Access = private)
        
        function colChk = checkCollateral(this, newTrade)
            % Check if sufficient collateral exists for a newTrade by
            % constructing all output combinations for the trader. 
            
            % Select own trades
            traderId = newTrade.traderId;
            ownTrades = this.orderBook(this.orderBook.traderId == traderId, :);
            % Get all root markets
            rootMarkets = this.marketTable(this.marketTable.marketBranchId == 1, :)
            % Get own root  markets
            ownRootMarkets = rootMarkets(ismember(rootMarkets.marketRootId,...
                [ownTrades.marketRootId(:); newTrade.marketRootId(:)]), :);
            
            % Construct corner outcome combinations in root markets (cell array of marketTables)
            outcomeCombinations = this.constructOutcomeCombinations(ownRootMarkets);
            
            for iComb = 1 : length(outcomeCombinations)
                % Add fixed outcomes to market table
                marketTable_test = vertcat(this.marketTable,...
                    outcomeCombinations{iComb});
                % Construct payoff
                matchedTrades = ownTrades(ownTrades.isMatched==1, :);
                openTrades = ownTrades(ownTrades.isMatched==0, :);
                
                if ~isempty(matchedTrades)
                    matchedTradePayoffs = this.constructPayoff(matchedTrades,...
                        marketTable_test);
                else
                    matchedTradePayoffs = 0
                end
                
                if ~isempty(openTrades)
                    openTradePayoffs =  this.constructPayoff(openTrades,...
                        marketTable_test);
                else
                    openTradePayoffs = 0;
                end
                newTradePayoff = this.constructPayoff(newTrade, marketTable_test);
                
                % Collateral is all matched trades + worst open trade + worst
                % outcome on new trade
                collateral(iComb,:) = sum(matchedTradePayoffs) + min(openTradePayoffs) + ...
                    min(newTradePayoff)
                
            end % iComb
            
            % Collateral available  under all worst outcomes
            colChk = all(collateral>=0);
            
            % TODO: colChk set =1 for testing
            colChk = 1;
        end % checkCollateral
        
        function marketOutcomes = constructOutcomeCombinations(this, marketTable)
            % Construct all possible outcome combinations root markets
            % Output:
            % marketOutcomes is a marketTable with each possible combination of
            % extrema for existing markets.
            
            % Get highest market minimum for each root market
            marketMaxMin = varfun(@max, marketTable, 'InputVariables',...
                'marketMin', 'GroupingVariables',...
                {'marketRootId'});
            
            % Get lowest market maximum for each root market
            marketMinMax = varfun(@min, marketTable, 'InputVariables',...
                'marketMax', 'GroupingVariables',...
                {'marketRootId'});
            
            % Extrema for each market
            marketExtrema = innerjoin(marketMaxMin, marketMinMax, 'Keys',...
                {'marketRootId'});
            % Rename extrema as marketMin and marketMax
            marketExtrema.Properties.VariableNames(...
                ismember(marketExtrema.Properties.VariableNames,...
                'min_marketMax')) = {'marketMax'};
            marketExtrema.Properties.VariableNames(...
                ismember(marketExtrema.Properties.VariableNames,...
                'max_marketMin')) = {'marketMin'};
            marketExtrema = marketExtrema(:,...
                {'marketRootId', 'marketMin',...
                'marketMax'});
            % Market min/max outcomes
            % {[market 1 min, market 1 max], [market 2 min, market 2 max], ...}
            for iMarket = 1 : height(marketExtrema)
                tmpOutcome{iMarket} = marketExtrema{iMarket, {'marketMin',...
                    'marketMax'}};
            end % iMarket
            
            % Get all combinations
            marketCombinations = this.cartesian(tmpOutcome);
            numCombinations = size(marketCombinations, 1);
            numMarkets = size(marketCombinations,2)
            
            for iOutcome = 1 : numCombinations
                mT = marketTable;
                marketIds = mT.marketRootId;
                % Set market min/max to each outcomme combination
                for iMarket = 1 : numMarkets
                    mT{mT.marketRootId == marketIds(iMarket),...
                        {'marketMin', 'marketMax'}} = ...
                        [marketCombinations(iOutcome, iMarket),...
                        marketCombinations(iOutcome, iMarket)];
                end % jOutcome
                marketOutcomes{iOutcome} = mT;
            end % iMarket
            
        end % constructOutputCombinations
        
        function payoffs = constructPayoff(this, tradeTable, marketTable)
            % Construct minimum payoffs for each trades given marketTable.
            % Output:
            % payoffs - minimum calculated possible payoff for each trade
            
            % Get highest market minimum for each market
            marketMaxMin = varfun(@max, marketTable, 'InputVariables',...
                'marketMin', 'GroupingVariables',...
                {'marketRootId', 'marketBranchId'});
            
            % Get lowest market maximum for each market
            marketMinMax = varfun(@min, marketTable, 'InputVariables',...
                'marketMax', 'GroupingVariables',...
                {'marketRootId', 'marketBranchId'});
            
            % Cumulative minimum along each market branch (inelegant)
            for iMarket = 1 : height(marketMaxMin)
                mRId = marketMaxMin(iMarket, :).marketRootId;
                mBId = marketMaxMin(iMarket, :).marketBranchId;
                parentMarkets = marketMaxMin(marketMaxMin.marketRootId...
                    == mRId & marketMaxMin.marketBranchId <= mBId, :);
                % Higest market minium at branch
                marketMaxMin.branchMarketMin(iMarket) =...
                    max(parentMarkets.max_marketMin);
            end % iMarket
            
            % Cumulative maximum along each market branch
            for iMarket = 1 : height(marketMaxMin)
                mRId = marketMinMax(iMarket, :).marketRootId;
                mBId = marketMinMax(iMarket, :).marketBranchId;
                parentMarkets = marketMinMax(marketMinMax.marketRootId== mRId ...
                    & marketMinMax.marketBranchId <= mBId,:);
                % Lowest market maximum at branch
                marketMinMax.branchMarketMax(iMarket) =...
                    min(parentMarkets.min_marketMax);
            end % iMarket
            
            % Add maxmin and minmax to tradeTable
            minMax_test = outerjoin(tradeTable, marketMinMax,...
                'Type', 'left', 'MergeKeys', true);
            
            maxMin_test = outerjoin(tradeTable, marketMaxMin,...
                'Type', 'left', 'MergeKeys', true);
            
            % Construct  payoff in both  casess
            minMax_payoff = (minMax_test.branchMarketMax -...
                minMax_test.price) .* minMax_test.quantity;
            maxMin_payoff = (maxMin_test.branchMarketMin -...
                maxMin_test.price) .* maxMin_test.quantity;
            
            % Worst possible payoffs for each trade in tradeTable
            payoffs = min([minMax_payoff, maxMin_payoff], [], 2);
            
        end % constructPayoff
        
        function this = matchTrades(this)
            % Match trades
            
            % Iterate through markets
            for iMarket = 1 : height(this.marketTable)
                allMatched = false
                marketTmp = this.marketTable(iMarket,:);
                while allMatched == false
                    % Get current unmatched trades for target market
                    ob = innerjoin(this.orderBook,...
                        marketTmp(:,{'marketRootId','marketBranchId'}));
                    ob = ob(ob.isMatched == 0,: );
                    ob.countInd = ones(height(ob),1);
                    % Calculate net open orders for each trader
                    netOrderBook = varfun(@sum, ob, 'GroupingVariables',...
                        {'traderId', 'tradeRootId', 'marketRootId', 'marketBranchId', 'price'},...
                        'InputVariables', {'quantity', 'countInd'});
                    netOrderBook.priority = netOrderBook.tradeRootId./...
                        netOrderBook.sum_countInd;
                    % Separate bids and asks
                    bids = sortrows(netOrderBook(...
                        netOrderBook.sum_quantity > 0, :), 'price', 'ascend');
                    asks = sortrows(netOrderBook(...
                        netOrderBook.sum_quantity < 0, :), 'price', 'descend');
                    % Get max bid and min ask
                    maxBid = bids(bids.price == max(bids.price), :);
                    minAsk = asks(asks.price == min(asks.price), :);
                    
                    if minAsk.price <= maxBid.price
                        % set price according to which trade was first
                        if maxBid.priority < minAsk.priority
                            tradePrice = maxBid.price
                        else
                            tradePrice = minAsk.price
                        end
                        % Trade quantity is lesser of the two
                        tradeQuantity = min(abs(maxBid.sum_quantity ),...
                            abs(minAsk.sum_quantity))
                        
                        % Unmatched target bid
                        targetBid = table(maxBid.tradeRootId, 0, tradePrice,...
                            tradeQuantity, maxBid.marketRootId,...
                            maxBid.marketBranchId, maxBid.traderId,...
                            {'sigMsg'}, {'sig'},...
                            'VariableNames',...
                            {'tradeRootId',...
                            'isMatched', 'price','quantity',...
                            'marketRootId', 'marketBranchId',...
                            'traderId', 'signatureMsg', 'signature'});
                        
                        % Unmatched target ask
                        targetAsk = table(minAsk.tradeRootId, 0, tradePrice,...
                            -tradeQuantity, minAsk.marketRootId,...
                            minAsk.marketBranchId, minAsk.traderId,...
                            {'sigMsg'}, {'sig'},...
                            'VariableNames',...
                            {'tradeRootId',...
                            'isMatched', 'price','quantity',...
                            'marketRootId', 'marketBranchId',...
                            'traderId', 'signatureMsg', 'signature'});
                        checkBid = this.checkCollateral(targetBid);
                        checkAsk = this.checkCollateral(targetAsk);
                        if checkBid & checkAsk
                            % add both trades to matched and offset from
                            % unmatched
                            this = this.writeMatchedTrade(targetBid);
                            this = this.writeMatchedTrade(targetAsk);
                        elseif checkBid & ~ checkAsk
                            % Remove marginal trade from bid
                            this = this.reduceMarginalTrade(targetAsk);
                        elseif ~checkBid & checkAsk
                            % Remove marginal trade from ask
                            this = this.reduceMarginalTrade(targetBid);
                        elseif ~checkBid & ~checkAsk
                            % Remove marginal trade from bid and ask
                            this = this.reduceMarginalTrade(targetAsk);
                            this = this.reduceMarginalTrade(targetBid);
                        end %
                    else
                        % No trades to match
                        allMatched = true;
                    end % minAsk.price <= maxBid.price
                    
                end % while allMatched = false
            end % iMarket
            
        end % matchedTrades
        
        function this = writeMatchedTrade(this, targetTrade)
            % Add trade by finding closest valid offset and matched trade
            
            % Write offset to original unmatched trade (previous sig from root trade)
            % Find closest offset trade
            offsetTrade = this.findValidOffsetTrade(targetTrade);
            % Add offset trade  (TODO sig check in function)
            this.orderBook = vertcat(this.orderBook, offsetTrade);
            % Write matched ( previous sig from offset trade)
            % Find closest match trade
            matchedTrade = this.findValidMatchedTrade(targetTrade);
            % Add match trade (TODO: sig check in function)
            this.orderBook = vertcat(this.orderBook, matchedTrade);
        end % writeMatchedTrade
        
        function this = reduceMarginalTrade(this, targetTrade)
            % Add offsetting trade (sig check from root trade)
            reduceTrade = this.findValidReduceTrade(targetTrade);
            % TODO sig check in function
            this.orderBook = vertcat(this.orderBook, reduceTrade);
        end % writeMatchedTrade
        
        function offsetTrade = findValidOffsetTrade(this, targetTrade)
            % Return closest valid offset trade (unmatched)
            tt = targetTrade;
            tt.quantity = -1*tt.quantity;
            tt.isMatched = 0;
            tt.tradeBranchId = 111;
            offsetTrade = tt;
            
            % FUTURE:
            % Request signature for offset trade or take from batch
            
        end % findValidMatchedTrade
        
        function matchedTrade = findValidMatchedTrade(this, targetTrade)
            % Return closest valid matched trade 
            tt = targetTrade;
            tt.isMatched = 1;
            tt.tradeBranchId = 222;
            matchedTrade = tt;
            
        end % findValidMatchedTrade
        
        function reduceTrade = findValidReduceTrade(this, targetTrade)
            tt = targetTrade;
            % Reduce quantity by 10%
            tt.quantity = -0.9*tt.quantity;            
            tt.isMatched = 0;
            tt.tradeBranchId = 300;
            reduceTrade = tt;
            
            % Return smallest valid reduce trade (isMatched = 0), opposite sign
%             ob = this.orderBook(this.orderBook.isMatched == 0 &...
%                 sign(this.orderBook.quantity) == -1*sign(targetTrade.quantity) & ...
%                 abs(this.orderBook.quantity) <= abs(targetTrade.quantity) &...
%                 this.orderBook.traderId == targetTrade.traderId &...
%                 this.orderBook.marketRootId == targetTrade.marketRootId, :);
%             % Smallest possible reduce trade
%             reduceTrade = ob(abs(ob.quantity) == min(abs(ob.quantity)), :);
        end % findValidMatchedTrade
        
    end % private methods
    
    
    methods (Access = private, Static)
        
        function C = cartesian(input)
            % Construct cartesian product of e.g. {{[1 2]}, {[2 3]}, {[4,5]}}.
            % Used to create combination of min/max market outcomes across
            % multiple markets.
            
            args = input;
            n = length(input);
            [F{1:n}] = ndgrid(args{:});
            for i=n:-1:1
                G(:,i) = F{i}(:);
            end
            C = unique(G , 'rows');
        end % cartesian
        
        function struct2var(s)
            %STRUCT2VAR Convert structure array to workspace variables.
            %   STRUCT2VAR(S) converts the M-by-N structure S (with P fields)
            %   into P variables defined by fieldnames with dimensions M-by-N.  P
            %   variables are placed in the calling workspace.
            %
            %   Example:
            %     clear s, s.category = 'tree'; s.height = 37.4; s.name = 'birch';
            %     c = struct2cell(s); f = fieldnames(s);
            %
            %   See also STRUCT2CELL, FIELDNAMES.

            % Copyright 2010 The MathWorks, Inc.
            if nargin < 1
                error('struct2var:invalidInput','No input structure found')
            elseif nargin > 1
                error('struct2var:invalidInput','Too many inputs')
            elseif ~isstruct(s)
                error('struct2var:invalidInput','Input must be a structure data type')
            end

            [r,c] = size(s);
            names = fieldnames(s);

            for i=1:length(names)
                assignin('caller',names{i},s.(names{i}))
            end

        end % struct2var
        
    end % private methods
    
end % marketObject_new



