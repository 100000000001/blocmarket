{"exec_count":1,"input":"\n\n","state":"done","pos":6,"cell_type":"raw","type":"cell","id":"0fbb99","kernel":"python3"}
{"exec_count":11,"input":"from IPython.display import Image","state":"done","pos":3,"cell_type":"raw","type":"cell","id":"0a00ba","kernel":"python3"}
{"exec_count":19,"input":"Here's our logo (hover to see the title text):\n\nInline-style: \n![alt text](https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png \"Logo Title Text 1\")\n","state":"done","pos":7,"cell_type":"raw","type":"cell","id":"384c1f","kernel":"python3"}
{"input":"","pos":4,"cell_type":"code","type":"cell","id":"d689f3","kernel":"python3"}
{"type":"cell","id":"3f807d","pos":2,"input":"$x^2/2$\n\n$\\int_{-\\infty}^{\\infty} f(x) dx$\n\n$poop^{girlfriend}$","cell_type":"markdown"}
{"type":"cell","id":"7726b0","pos":1,"input":"1+2\n\n\n","cell_type":"markdown"}
{"type":"cell","id":"a7a862","pos":8,"input":"Here's our logo (hover to see the title text):\n\nInline-style: \n![alt text](https://github.com/adam-p/markdown-here/raw/master/sr"}
{"type":"cell","id":"daf287","pos":0,"input":"# Protocol for a distributed synthetic market\n\nThis is a protocol for matching **state contingent contracts** linear between an upper and lower bound and at a particular expiry.\n\n<img src=\"img/BFC.png\"  width=500>\n\nThese contracts can be combined to construct standard forward and option contracts or event markets (payoffs depending on a discrete). \n\n<img src=\"img/StackedBFC.png\" width=500>\n\nThe protocol uses a chain of signatures to verify orders. Orders are accepted by the market if they have a valid signature and the trader's positions satisfiy a collateral check across all possible worst outcomes.\n\nMarkets are settled by the market owner adding a new upper and lower bound for a market equal to a single number. For example, the lower bound for each market is the highest lower bound for itself of any sub-market or any previous.\n\n[figure]\n\n\n## Data structures\n\n### A market\n\nA **market** is defined by:\n\n- 'marketRootId': (integer) market id\n- 'marketBranchId': (integer) sub-markets >1 (sub-markets bounded by super-markets)\n- 'marketMin' - (float) minimum possible outcome\n- 'marketMax' - (float) maximum possible outcome\n- 'traderId' - (integer) market owner trader ID\n- 'signatureMsg' - (string) message for signature\n- 'signature' - (binary) signed message\n\nE.g.\n\nMarket with (root = 3, branch = 1); market bounded between (0, 1); owned by trader 1 and signed.\n\n~~~~\n\ntestMarket = struct('marketRootId', 3, 'marketBranchId', 1,...\n                                'marketMin', 0, 'marketMax', 1,...\n                                'traderId', 1, 'signatureMsg','sigmsg1',...\n                                'signature', 'sig1')\n\n~~~~\n\n- Sub markets have marketMin/marketMax bounded by superMarkets.\n- Any amount of valid markets with the same root/branch can be added and the market will take the highest minimum and the lowest maximum.\n\n\n### An order\n\nAn **order** in a market is defined by:\n\n - 'tradeRootId': (integer) trade root id\n - 'tradeBranchId': (integer) subtrades (dependent trades such as offsets and partials)\n - 'isMatched': (boolean) is trade matched (adding an unmatched trade requries adding an offsetting trade and adding an equal sized matched trade from cache)\n - 'price':  (float) price of trade \n - 'quantity':  (float) quanitity of trade (positive quantity for bids, negative for offers) \n - 'marketRootId' : (integer) market id\n - 'marketBranchId': (integer) sub-markets > 1 (sub-markets bounded by super-markets)\n - 'traderId':  (integer) trade owner trader ID\n - 'tradeType': (integer) Primary = 1, pArtial = 1, Offset = 3, Reduction = 4\n - 'signatureMsg' - (string) message for signature\n - 'signature' - (binary) signed message\n\nE.g. \n\nUnmatched primary trade (price = 0.5, quantity = 10) on market (root = 1, branch = 1)\n\n~~~~\n\ntestTrade = struct('traderId', 1, 'tradeRootId', 1, 'tradeBranchId', 1,...\n                'isMatched', 0, 'price', 0.5,...\n                'quantity', 10, 'marketRootId', 3,...\n                'marketBranchId', 1,'signatureMsg',...\n                'tradeType, 1,'sigMsg', 'signature', 'sig');\n\n~~~~\n\n\n[Dictionary trade example]\n\nTrades can be added to the order book but not removed or changed except for the 'tradeType' field which determines if the trade should be considered in collateral calculations.\n\n#### Geometry of an order\n\nSince orders can only be added to the order book and not subtracted, creating a matched order requires an offset of the unmatched order and a new matched order of equal size.\n\nConsider an order '(p=0.5, q=0.5)'. For the trade to successfully be matched it requires at minimum:\n\n- Primary  (p=0.5, q=10, isMatched = 0) \n- Offset  (p=0.5, q=-10, isMatched = 0)\n- Match (p=0.5, q=10, isMatchced = 1)\n\nOptionally, the trade an also include a reduction trade for the market to use to kill an existing order to make way for a new order. These don't need offsets.\n\n- Reduction  (p=0.5, q=10*-0.1=-1, isMatched=1)\n\nGeometrically, this set of trades can be represented in (p,q) space:\n\n<img src=\"img\\OrderGeometry1.png\" width = 600>\n\nIt is useful to allow partial fills (lower quantity and weakly better price). Each partial trade only requires a matched version and not an offset.\n\n[Geometry of single trade with partial fill region]\n\nAny non-primary trade that is picked up for a match is set as primary by the system so it can be picked up in future collateral calculations (this is the only changable field in the order book).\n\n\n#### Geometry of signature chain \n\nEach trade is chained to a previous trade according to some rule. The order book will require a valid signature (valid signature for message and valid previous node) and a collateral check. Primary and partial orders are chained to a previous valid order, while offset and reductions are chained to the primary trade.\n\n[Pictures: \nPrevious valid -> Primary -> Primary offset cone -> Primary matched rectangle\nPrevious valid -> Primary -> Partial -> Partial offset cone -> Matched rectangle\n]\n\n## Methods\n\n\n[methods]\n","cell_type":"markdown"}
{"type":"cell","id":"f30b1f","pos":5,"input":"","cell_type":"code","exec_count":0}
{"type":"file","last_load":1515682930123}
{"type":"settings","kernel":"python3","metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.5.2"}},"backend_state":"running","trust":true,"kernel_usage":{"cpu":0,"memory":87699456},"kernel_state":"idle"}