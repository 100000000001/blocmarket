{"type":"settings","kernel":"python3","kernel_state":"idle","backend_state":"running","trust":true,"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.6.0"}},"kernel_usage":{"cpu":0,"memory":79028224}}
{"type":"cell","id":"856f64","pos":0,"input":"# Protocol for a distributed synthetic market\n\nThis is a protocol for matching **state contingent contracts** linear between an upper and lower bound and at a particular expiry.\n\n[figure of BFC]\n\nThese contracts can be combined to construct standard forward and option contracts or event markets (payoffs depending on a discrete). \n\n[figure of normal future contact]\n\nThe protocol uses a chain of signatures to verify orders. Orders are accepted by the market if they have a valid signature and the trader's positions satisfiy a collateral check across all possible worst outcomes.\n\nMarkets are settled by the market owner adding a new upper and lower bound for a market equal to a single number. For example, the lower bound for each market is the highest lower bound for itself of any sub-market or any previous.\n\n[figure]\n\n\n## Data structures\n\n### A market\n\nA **market** is defined by:\n\n- 'marketRootId': (integer) market id\n- 'marketBranchId': (integer) sub-markets >1 (sub-markets bounded by super-markets)\n- 'marketMin' - (float) minimum possible outcome\n- 'marketMax' - (float) maximum possible outcome\n- 'traderId' - (integer) market owner trader ID\n- 'signatureMsg' - (string) message for signature\n- 'signature' - (binary) signed message\n\nE.g.\n\nMarket with (root = 3, branch = 1); market bounded between (0, 1); owned by trader 1 and signed.\n\n~~~~\n\ntestMarket = struct('marketRootId', 3, 'marketBranchId', 1,...\n                                'marketMin', 0, 'marketMax', 1,...\n                                'traderId', 1, 'signatureMsg','sigmsg1',...\n                                'signature', 'sig1')\n\n~~~~\n\n- Sub markets have marketMin/marketMax bounded by superMarkets.\n- Any amount of valid markets with the same root/branch can be added and the market will take the highest minimum and the lowest maximum.\n\n\n### An order\n\nAn **order** in a market is defined by:\n\n - 'tradeRootId': (integer) trade root id\n - 'tradeBranchId': (integer) subtrades (dependent trades such as offsets and partials)\n - 'isMatched': (boolean) is trade matched (adding an unmatched trade requries adding an offsetting trade and adding an equal sized matched trade from cache)\n - 'price':  (float) price of trade \n - 'quantity':  (float) quanitity of trade (positive quantity for bids, negative for offers) \n - 'marketRootId' : (integer) market id\n - 'marketBranchId': (integer) sub-markets > 1 (sub-markets bounded by super-markets)\n - 'traderId':  (integer) trade owner trader ID\n - 'tradeType': (integer) Primary = 1, pArtial = 1, Offset = 3, Reduction = 4\n - 'signatureMsg' - (string) message for signature\n - 'signature' - (binary) signed message\n\nE.g. \n\nUnmatched primary trade (price = 0.5, quantity = 10) on market (root = 1, branch = 1)\n\n~~~~\n\ntestTrade = struct('traderId', 1, 'tradeRootId', 1, 'tradeBranchId', 1,...\n                'isMatched', 0, 'price', 0.5,...\n                'quantity', 10, 'marketRootId', 3,...\n                'marketBranchId', 1,'signatureMsg',...\n                'tradeType, 1,'sigMsg', 'signature', 'sig');\n\n~~~~\n\n\n[Dictionary trade example]\n\nTrades can be added to the order book but not removed or changed except for the 'tradeType' field which determines if the trade should be considered in collateral calculations.\n\n#### Geometry of an order\n\nSince orders can only be added to the order book and not subtracted, creating a matched order requires an offset of the unmatched order and a new matched order of equal size.\n\nConsider an order '(p=0.5, q=0.5)'. For the trade to successfully be matched it requires at minimum:\n\n- Primary trade (p=0.5, q=10, isMatched = 0) \n- Offset trade (p=0.5, q=-10, isMatched = 0)\n- Primary match (p=0.5, q=10, isMatchced = 1)\n\nOptionally, the trade an also include a reduction trade for the market to use to kill an existing order to make way for a new order. These don't need offsets.\n\n- Reduction trade (p=0.5, q=10*-0.1=-1, isMatched=1)\n\nGeometrically, this set of trades can be represented in (p,q) space:\n\n[4 trade geometry picture - from market draw method]\n\nIn practice it would be sensible to have a set of possible partial fills (lower quantity and weakly better price). Each partial trade only requires a matched version since it would only be used during trade matching and would not exist as an open order.\n\n[Geometry of single trade with partial fill region]\n\nAny non-primary trade that is picked up for a match is set as primary by the system so it can be picked up in future collateral calculations (this is the only changable field in the order book).\n\n\n#### Geometry of signature chain \n\nEach trade is chained to a previous trade according to some rule. The order book will require a valid signature (valid signature for message and valid previous node) and a collateral check but is otherwise agnostic about orders. Primary and partial orders are signed off the previous valid order (PVO), while offset and reductions enter the order book as matched (but not primary).\n\n[Pictures: \nPrevious valid -> Primary -> Primary offset cone -> Primary matched rectangle\nPrevious valid -> Partial -> Partial offset cone -> Matched rectangle\n]\n\n## Methods\n\n\n[methods]\n","cell_type":"markdown"}
{"output":{"0":{"data":{"text/plain":"3"},"exec_count":11}},"exec_count":11,"start":1515235325451,"input":"1+2\n\n\n","state":"done","pos":1,"cell_type":"code","type":"cell","end":1515235325464,"id":"376dbe","kernel":"python3"}
{"output":{"0":{"data":{"text/plain":"'/home/user/pmarket'"},"exec_count":12}},"exec_count":12,"start":1515235326446,"input":"%pwd","state":"done","pos":2,"cell_type":"code","type":"cell","end":1515235326453,"id":"40af40","kernel":"python3"}
{"type":"file","last_load":1515223578886}
{"type":"cell","id":"e43c36","pos":7,"input":""}
{"type":"cell","id":"91300c","pos":8,"input":"","cell_type":"markdown"}
{"type":"cell","id":"8d94b4","pos":4.5,"input":""}
{"type":"cell","id":"73f722","pos":3.25,"input":"","cell_type":"code"}
{"type":"cell","id":"5ffb17","pos":9,"input":""}