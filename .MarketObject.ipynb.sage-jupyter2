{"type":"cell","id":"168543","pos":12,"input":"$x^2$","cell_type":"markdown"}
{"type":"cell","id":"18d3b2","pos":15,"input":"a=1\na","output":{"0":{"data":{"text/plain":"1"},"output_type":"execute_result","exec_count":4}},"cell_type":"code","exec_count":4}
{"type":"cell","id":"199b75","pos":13,"input":"\n1+1","output":{"0":{"data":{"text/plain":"2"},"output_type":"execute_result","exec_count":2}},"cell_type":"code","exec_count":2,"scrolled":true}
{"type":"cell","id":"46e8cc","pos":1,"input":"## Data structures\n\n### A market\n\nA **market** is defined by:\n\n- 'marketRootId': (integer) market id\n- 'marketBranchId': (integer) sub-markets >1 (sub-markets bounded by super-markets)\n- 'marketMin' - (float) minimum possible outcome\n- 'marketMax' - (float) maximum possible outcome\n- 'traderId' - (integer) market owner trader ID\n- 'signatureMsg' - (string) message for signature\n- 'signature' - (binary) signed message\n\nE.g.\n\nMarket with (root = 3, branch = 1); market bounded between (0, 1); owned by trader 1 and signed with signature 'sig1'.\n\n~~~~\n\ntestMarket = struct('marketRootId', 3, 'marketBranchId', 1,...\n                                'marketMin', 0, 'marketMax', 1,...\n                                'traderId', 1, 'signatureMsg','sigmsg1',...\n                                'signature', 'sig1')\n\n~~~~\n\n- Sub markets have marketMin/marketMax bounded by markets with the same root but lower branch id.\n- Any amount of valid markets with the same root/branch can be added and the market will take the highest minimum and the lowest maximum.\n\n\n","cell_type":"markdown"}
{"type":"cell","id":"4dce58","pos":4,"input":"\n#### Geometry of signature chain \n\nEach trade is chained to a previous trade according to a rule. The order book will require a valid signature (valid signature for message and valid previous node) and a collateral check to ensure the trader has sufficient collateral. Primary orders are chained to a previous valid order, offset are chained to the primary trade.\n\nThe figure below is an order to buy at 0.5 with associated offset and match trades.\n\n<img src=\"img\\BasicSignature1.jpeg\" width = 300>\n\nIf the order is matched by a sell contract at 0.5 the the offset and match contracts are removed from the cache and added to the order book where they remain forever.\n","cell_type":"markdown"}
{"type":"cell","id":"59ff8f","pos":3,"input":"#### Geometry of an order\n\nSince orders can only be added to the order book and not subtracted, creating a matched order requires an offset of the unmatched order and a new matched order of equal size.\n\nConsider an order '(p=0.5, q=1)'. For the trade to successfully be matched it requires at minimum:\n\n- Primary  (p=0.5, q=1, isMatched = 0) \n- Offset  (p=0.5, q=-1, isMatched = 0)\n- Match (p=0.5, q=1, isMatchced = 1)\n\n\nGeometrically, this set of trades can be represented in (p,q) space with with offset (blue) and match (green):\n\n<img src=\"img\\OrderGeometry1.jpeg\" width = 300>\n\nThe offset and match trades are initally held in a separate **cache** order book and are promoted when the trade is matched. The cache order book is a place for signed but unused trades and has no implact on collateral calculations.\n\nWith a small loss of generality, the mechanics of orders here are all unit quantity and there are no partial fills.","cell_type":"markdown"}
{"type":"cell","id":"5db306","pos":11,"input":"- Match trade (10,0.5) with all signature chain and cache\n- Some idea for which last signature to use\n- How to prevent malicious use of cache orders? \n","cell_type":"raw"}
{"type":"cell","id":"a6683b","pos":16,"input":"","cell_type":"code","exec_count":0}
{"type":"cell","id":"ad2cb9","pos":14,"input":"","cell_type":"markdown"}
{"type":"cell","id":"aeac38","pos":7,"input":"##### Example sequence of orders: Better price match\n\nNow consider a case where trader 1 has a bid at 0.5 and trader 2 offers at  0.4. The trade still matches at 0.5 since trader 1 was there first. Trader 2's offset for the p=0.4 trade is promoted to the order book.\n\n\n<img src=\"img\\BetterPriceMatch.jpeg\" width = 600>","cell_type":"markdown"}
{"type":"cell","id":"b1b92e","pos":9,"input":"##### Example sequence of orders: Chaining to a previous valid order\n\nPicking up from the previous example now suppose trader 3 enters the market with an offer for 0.7 and a better price offer at 0.8. The order is chained to the highest number trade existing in the order book which is (2.3 from the p=0.5 trade). If another trade came into the order book it would be chained to 3.1 since it is the largest number in the order book.\n\n<img src=\"img\\BetterPriceMatchChained.jpeg\" width = 600>\n","cell_type":"markdown","exec_count":0}
{"type":"cell","id":"b8000d","pos":9.5,"input":""}
{"type":"cell","id":"c96bc1","pos":5,"input":"##### Example sequence of orders: Single order perfect match\n\nThe simplest case is a perfect match of primary trades. Trader 1 enters the market and posts a bid for 1 contracts at 0.5 into the order book, and a corresponding offset and match order into the cache. Offsets and matches share the same root id.\n \n*Trader 1:*  \n- 1.1 Primary: traderId=1, tradeRootId = 1, tradeBranchId = 1, p=0.5, q=1, isMatched=0  (primary)\n- 1.2 Offset: traderId=1, tradeRootId = 1, tradeBranchId = 2, p=0.5, q=-1, isMatched=0  (cache)\n- 1.3 Match: traderId=1, tradeRootId = 1, tradeBranchId = 3, p=0.1, q=1, isMatched=1    (cache)\n\n\nNow trader 2 posts a matching bid for -1 contracts at 0.5, with corresponding offset and match in cache:\n\n*Trader 2:*  \n- 2.1 Primary: traderId=2, tradeRootId = 2, tradeBranchId = 1, p=0.5, q=-1, isMatched=0  (primary)\n- 2.2 Offset: traderId=2, tradeRootId = 2, tradeBranchId = 2, p=0.5, q=1, isMatched=0  (cache)\n- 2.3 Match: traderId=2, tradeRootId = 2, tradeBranchId = 3, p=0.5, q=-1, isMatched=1  (cache)\n\n<img src=\"img\\PerfectMatch.jpeg\" width = 600>\n\nMatching proceeds by adding the the offset and match trades to the order book. ","cell_type":"markdown"}
{"type":"cell","id":"d0fd1a","pos":0,"input":"# Protocol for a distributed synthetic market\n\nThis is a protocol for matching **state contingent contracts** that give a payoff linear between an upper and lower bound and at a particular expiry.\n\n<img src=\"img/BFC.png\"  width=500>\n\nFor example the contract might pay \\$1 for each 10mm of rainfall above 30mm. If the amount of rainfall is above 30mm the payoff is \\$1 and if the outcome is below 30mm the outcome is zero.\n\nThese contracts can be combined to construct standard forward and option contracts or event markets (payoffs depending on a discrete set of outcomes). \n\n<img src=\"img/StackedBFC.png\" width=500>\n\nThe protocol uses a chain of signatures to organize buy and sell orders for these contracts. Orders are accepted if they have a valid signature and the trader's positions satisfiy a collateral check across all possible worst outcomes. To maintain an appropriate record of the order book, trades can only be added, and the validity of any trade can be checked by anyone using public keys provided by each participant.\n\nMarkets are settled by the market owner adding a new upper and lower bound for a market equal to a single number. For example, the lower bound for each market is the highest lower bound for itself of  any sub-market or any previous bound on the same market. Market bounds *telescope*, making a market the *underlying asset* of its sub-markets. \n\n<img src=\"img/marketBounds.png\" width=600>\n\n\n\n","cell_type":"markdown"}
{"type":"cell","id":"e2ac9e","pos":10,"input":"\n\n","cell_type":"markdown"}
{"type":"cell","id":"f0eb3a","pos":2,"input":"\n### An order\n\nAn **order** in a market is defined by:\n\n - 'tradeRootId': (integer) trade root id\n - 'tradeBranchId': (integer) subtrades (dependent trades such as offsets and partials)\n - 'isMatched': (boolean) is trade matched (adding an unmatched trade requries adding an offsetting trade and adding an equal sized matched trade from cache)\n - 'price':  (float) price of trade\n - 'quantity':  (float) quanitity of trade (positive quantity for bids, negative for offers) \n - 'marketRootId' : (integer) market id\n - 'marketBranchId': (integer) sub-markets > 1 (sub-markets bounded by super-markets)\n - 'traderId':  (integer) trade owner trader ID\n - 'signatureMsg' - (string) message for signature\n - 'signature' - (binary) signed message\n\nE.g. \n\nUnmatched primary trade (price = 0.5, quantity = 10) on market (root = 1, branch = 1)\n\n~~~~\n\ntestTrade = struct('traderId', 1, 'tradeRootId', 1, 'tradeBranchId', 1,...\n                'isMatched', 0, 'price', 0.5,...\n                'quantity', 10, 'marketRootId', 3,...\n                'marketBranchId', 1,'signatureMsg',...\n                'sigMsg', 'signature', 'sig');\n\n~~~~\n\n\nTrades can be added to the order book but not removed or changed. A separate cache order book is maintained for partial trades, offsets, and matches. The cache order book is ignored for collateral calculations.\n\n\n\n","cell_type":"markdown"}
{"type":"file","last_load":1520060676094}
{"type":"settings","kernel":"python3","metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.5.2"}},"backend_state":"running","trust":true,"kernel_usage":{"cpu":0,"memory":87896064},"kernel_state":"idle"}